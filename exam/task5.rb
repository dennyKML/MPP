# Метод heapify відновлює властивість купи для піддерева з коренем у вузлі 'i'
def heapify(arr, n, i)
  largest = i

  # Індексація дітей в бінарному дереві використовується за формулою:
  # ліва_дитина = 2 * батьківський_індекс + 1 для лівої дитини
  # права_дитина = 2 * батьківський_індекс + 2 для правої дитини
  l = 2 * i + 1
  r = 2 * i + 2

  # Порівняння лівої дитини та кореня
  if l < n && arr[largest] < arr[l]
    largest = l
  end

  # Порівняння правої дитини та кореня
  if r < n && arr[largest] < arr[r]
    largest = r
  end

  # Якщо найбільший елемент не корінь
  if largest != i
    # Міняємо місцями корінь і найбільший елемент
    arr[i], arr[largest] = arr[largest], arr[i]
    # Рекурсивно викликаємо heapify для піддерева
    heapify(arr, n, largest)
  end
end

# Метод heap_sort сортує масив, використовуючи алгоритм купи
def heap_sort(arr)
  n = arr.length

  # Будуємо максимальну купу починаючи з останнього рівня купи (рівень передостанній).
  # Ми обходимо всі вузли, які можуть мати дітей, і викликаємо heapify для кожного з них.
  # Це гарантує, що будь-яке піддерево є максимальною купою
  (n / 2 - 1).downto(0) do |i|
    heapify(arr, n, i)
  end

  # Поелементно вилучаємо елементи та відновлюємо купу
  # (починаємо з останнього елемента та обмінюємо його з коренем)
  (n - 1).downto(1) do |i|
    # Міняємо місцями корінь та поточний елемент
    arr[i], arr[0] = arr[0], arr[i]
    # Відновлюємо властивість купи для зменшеного піддерева
    heapify(arr, i, 0)
  end
end

arr = [86, 76, 93, 110, 87, 24, 17, 103, 0, 2]

puts "\nНе відсортований масив: #{arr}"
heap_sort(arr)
puts "Відсортований масив: #{arr}"